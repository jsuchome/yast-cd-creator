/**
 * File:	modules/CDCreator.ycp
 * Package:	Configuration of cd-creator
 * Summary:	Data for configuration of cd-creator, input and output functions.
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 *
 * Representation of the configuration of cd-creator.
 * Input and output routines.
 */

{

module "CDCreator";
textdomain "cd-creator";

import "Progress";
import "Report";
import "Summary";
import "XML";
import "InstSource";
import "URL";



global map meta = $[];

global list missing_packages = [];

global list toCopy = [];

/* Local variables */

string skel_root = "";




/* Configuration Map */
global map Config = $[];

/* All Configurations */
global map Configs = $[];

/* Configuration Repository */
global string Rep = "/var/lib/YaST2/cd-creator";

/* Configuration file */
global string ConfigFile = Rep + "/cdcreator.xml";

/**
 * Abort function
 * return boolean return true if abort
 */
global block<boolean> AbortFunction = nil;

/**
 * Data was modified?
 */
global boolean modified = false;

global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Data was modified?
 * @return true if modified
 */
global define boolean Modified() ``{
    y2debug("modified=%1",modified);
    return modified;
};

include "cd-creator/routines.ycp";


/**
 * Read all cd-creator settings
 * @return true on success
 */
global define boolean Read() ``{

    /* CDCreator read dialog caption */
    string caption = _("Initializing CD-Creator Configuration");

    integer steps = 1;

    integer sl = 2;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    // translators: progress stage 1/1
	    _("Read the configuration")
	], [
	    // translators: progress step 1/1
	    _("Reading the database..."),
	    // translators: progress finished
	    _("Finished")
	],
	""
    );

    // read database
    if(Abort()) return false;
    Progress::NextStage();

    map c = $[];
    if (SCR::Read(.target.size, ConfigFile) != -1 )
    {
	c = XML::XMLToYCPFile(ConfigFile);
    }
    list all = c["configurations"]:[];
    Configs = listmap (map i, all, ``{
	string name = i["name"]:"";
	return($[name: i]);
    });
    y2milestone("Configs: %1", Configs);

    // translators: error message
    if(false) Report::Error(_("Cannot read the configuration."));
    sleep(sl);


    if(Abort()) return false;
    // translators: progress finished
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}



/**
 * Prepare map for writing  into XML
 * @return lists of configurations
 */
global define list PrepareConfigs() ``{

    list c = maplist(string k, map v, Configs, ``{
	return(v);
    });
    return (c);
}

/**
 * Write all cd-creator settings
 * @return true on success
 */
global define boolean Write() ``{

    /* CDCreator read dialog caption */
    string caption = _("Saving cd-creator Configuration");

    integer steps = 2;

    integer sl = 50;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    // translators: progress stage 1/2
	    _("Write the settings"),
	], [
	    // translators: progress step 1/1
	    _("Writing the settings..."),
	    // translators: progress finished
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();

    list c = PrepareConfigs();
    map xml = $["configurations": c];
    boolean ret = XML::YCPToXMLFile(`cdcreator, xml, ConfigFile);

    // translators: error message
    if(!ret) Report::Error (_("Error while writing settings."));


    // run SuSEconfig
    if(Abort()) return false;
    Progress::NextStage ();
    // translators: error message
    if(false) Report::Error (_("SuSEconfig script failed."));
    sleep(sl);

    if(Abort()) return false;
    // translators: progress finished
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Get all cd-creator settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global define boolean Import (map settings) ``{
    return true;
}

/**
 * Dump the cd-creator settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global define map Export () ``{
    return $[];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global define list Summary() ``{
    // translators: Configuration summary text for autoyast
    return [ _("Configuration summary ..."), [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global define list Overview() ``{
    y2milestone("Configs: %1", Configs);
    list overview = maplist(string name , map cfg, Configs , ``{
	return(`item(`id(name), name, cfg["product"]:""));
    });
    return overview;
}


/**
 * Get media urls
 * @param list list of ids
 * @return list list of urls
 */
global define list getSourceURLs ( list ids ) ``{
    list urls = maplist(integer i , ids, ``{
	map media = Pkg::SourceMediaData(i);

	return(media["url"]:"");
    });

    return urls;
}


/**
 * get path to directory source
 * @param string url
 * @return string path
 */
global define string getSourceDir(string url) ``{
    map urlsegs = URL::Parse(url);
    return(urlsegs["path"]:"");
}
/**
 * Return contents of isolinux.cfg from the given source
 * @return string with contents of file.
 */
global define string Readisolinux() ``{

    string bootconfig = Config["bootconfig"]:"";
    if (bootconfig != "")
    {
	return bootconfig;
    }

    // FIXME
    string dir = getSourceDir(Config["sources", 0]:"" );
    
    string bootconfig_path = sformat("%1/boot/loader/isolinux.cfg", dir );
    if (SCR::Read(.target.size, bootconfig_path) != -1 )
	bootconfig = (string)SCR::Read(.target.string, bootconfig_path );
    return bootconfig;
}

/**
 * Create XML Configuration
 */
global define void configSetup()
    ``{
    map doc = $[];
    doc["listEntries"] =
	$[
	  "packages":"package",
	  "addons":"addon",
	  "configurations": "config"
	];
    doc["cdataSections"] = ["bootconfig"];
    doc["rootElement"] = "cd-creator";
    doc["systemID"] = "/usr/share/autoinstall/dtd/cd-creator.dtd";
    doc["nameSpace"] = "http://www.suse.com/1.0/yast2ns";
    doc["typeNamespace"] = "http://www.suse.com/1.0/configns";
    XML::xmlCreateDoc(`cdcreator, doc);
    return;
}


/**
 * Create Skeleton
 * @return boolean true on success
 */
global define boolean  CreateSkeleton (integer id) ``{

    list commands = [];
    integer ret = 0;
    boolean success = true;
    boolean savespace = Config["savespace"]:false;

    // Create skeleton directory
    skel_root = sformat("%1/%2", Config["iso-directory"]:"", Config["name"]:"");
    SCR::Execute(.target.mkdir, skel_root);

    map this_source = meta[id]:$[];
    string descrDir = this_source["productData","descrdir"]:"suse/setup/descr";
    string dataDir  = this_source["productData", "datadir"]:"./suse";
    y2milestone("source data: %1", this_source["sourceData", "url"]:"" );
    string source   = this_source["path"]:"";
    if (source == "")
        return false;

    success = (boolean)SCR::Execute(.target.mkdir, sformat("%1/%2", skel_root, dataDir));
    if (!success)
	return false;

    commands= add(commands, sformat("/bin/mkdir -p %1/boot", skel_root));
    commands= add(commands, sformat("/bin/mkdir -p %1/boot/loader", skel_root));
    commands= add(commands, sformat("/bin/mkdir -p   %1//%2",  skel_root, descrDir));

    if (savespace)
    {
	// Installation, rescue images
	commands= add(commands, sformat("/bin/cp  %1/boot/root %2/boot", source, skel_root));
	commands= add(commands, sformat("/bin/cp  %1/boot/rescue %2/boot", source, skel_root));

	// Loader, x86 specific
	commands= add(commands, sformat("/bin/cp  %1/boot/loader/* %2/boot/loader", source, skel_root));
	commands= add(commands, sformat("/bin/cp  %1/content %2", source, skel_root));

    }
    else
    {
	// Copy all the contents of /boot
	commands= add(commands, sformat("/bin/cp -a  %1/boot %2", source, skel_root));
	commands= add(commands, sformat("/bin/cp  %1/* %2", source, skel_root));
    }
    // Descriptions, Selections and package databases
    commands= add(commands,
		  sformat("/bin/cp -a %1/%2/* %3/%4",
			  source,
			  descrDir,
			  skel_root,
			  descrDir)
		  );

    // Prepare media files
    commands= add(commands, sformat("/bin/cp -a %1/media.1  %2", source, skel_root));
    commands= add(commands, sformat("/usr/bin/head -n 2 %1/media.1/media  >   %2/media.1/media.tmp && mv %2/media.1/media.tmp %2/media.1/media",  skel_root, skel_root));


    // Media nr.
    integer count = 1;

    commands= add(commands, sformat("/bin/echo %1 >> %2/media.1/media ", count,  skel_root));

    foreach (string c, commands, ``{
	ret = (integer)SCR::Execute (.target.bash, c);
    });

    return success;
}


/**
 * CopyMiscFiles
 * Copy other files to directory tree
 * @return boolean true on success
 */
global define boolean CopyMiscFiles() ``{

    string cpCmd = sformat("cp /usr/share/autoinstall/isolinux.cfg %1/boot/loader", skel_root);
    SCR::Execute (.target.bash, cpCmd);
    cpCmd = sformat("cp /usr/share/autoinstall/message %1/boot/loader", skel_root);
    SCR::Execute (.target.bash, cpCmd);
    cpCmd = sformat("cp /usr/share/autoinstall/options.msg %1/boot/loader", skel_root);
    SCR::Execute (.target.bash, cpCmd);


    return true;
}



/**
 * Enable source and get source meta data
 * @return true on success
 */
global define boolean EnableSource() ``{
    list<integer> sources = maplist(string url , CDCreator::Config["sources"]:[], ``{
	integer i = InstSource::getSourceID(url);
	return (i);
    });
    list ids = Pkg::SourceStartCache(true);
    if (size(ids) == 0 )
	return false;
    foreach(integer i , sources, ``{
	map<string, map> m = $[];
	m["productData"] = Pkg::SourceProductData(i);
	m["mediaData"] = Pkg::SourceMediaData(i);
	m["sourceData"]	= Pkg::SourceGeneralData(i);
        string p = m["sourceData", "url"]:"";
        m["path"] = lookup(URL::Parse(p), "path", "");
	meta[i] = m;
    });

    y2milestone("meta: %1", meta);
    return true;
}


/**
 * Get all possible sources
 * @return available enabled sources list for widget
 */
global define list GetDirSources(string source) ``{
    list ids = Pkg::SourceStartCache(true);
    list sources = [];
    foreach(integer i , ids, ``{
        map prod = Pkg::SourceProductData(i);
        map media = Pkg::SourceMediaData(i);
	map url = URL::Parse(media["url"]:"");
	if (url["scheme"]:"" == "dir")
	{
	    boolean selected = (source == url["path"]:"");
	    sources = add(sources, `item(`id(url["path"]:""), url["path"]:"", selected));

	}
    });

    return sources;
}


/**
 * Check Product dependencies and determine product to be used for
 * booting. Also determine what is the main product.
 *
 */
global define list checkProductDependency() ``{

    list sources =  maplist(string url , Config["sources"]:[], ``{
	integer i = InstSource::getSourceID(url);
	UI::ChangeWidget(`id(`table), `Item(i, 0) , _("X"));
	return (i);
    });

    list products = maplist(integer id , sources, ``{
	map generalData = Pkg::SourceGeneralData( id );
	map productData = Pkg::SourceProductData( id );

	map result = $[];

	result["baseproduct"] = sformat("%1-%2", productData["baseproductname"]:"", productData["baseproductversion"]:"" );
	result["vendor"] = productData["vendor"]:"";
	result["product"] = sformat("%1-%2", productData["productname"]:"", productData["productversion"]:"" );
	result["is_service_pack"] = ( issubstring(productData["productname"]:"", "Service-Pack") );
	result["id"] = id;
	return(result);
    });

    list final = maplist( map product, products, ``{
	list based_on_this = filter(map p, products, ``(product["product"]:"" == p["baseproduct"]:""));
	list ids = maplist(map p, based_on_this, ``(p["id"]:-1));
	y2milestone("Products based on %1: %2", product["product"]:"", based_on_this );
	product["dependents"] = ids;
	return(product);
    });


    map installedProduct = (map)select( (list)filter(map p, final, ``(size(p["dependents"]:[]) == 0
								      && !p["is_service_pack"]:false
								      && issubstring(p["vendor"]:"", "SuSE"))) , 0 , $[]);;
    Config["product"] = installedProduct["product"]:"";
    y2milestone("all: %1", final);
    return final;

}


global define void enableSources()``{


    list old_enabled = Pkg::SourceGetCurrent(true);
    foreach(integer id , old_enabled, ``{
		Pkg::SourceFinish(id);
	});
    list sources = Config["source_ids"]:[];

    foreach(integer id , sources, ``{
		Pkg::SourceSetEnabled(id, true);
	});
    return;

}



/**
 * Set packages to be copies to iso image tree
 * @return void
 */
global define boolean setPackages() ``{
    string base = Config["base"]:"";
    list<string> addons = Config["addons"]:[];
    list<string> packages  = Config["packages"]:[];
    list<string> post_packages  = Config["post-packages"]:[];
    string kernel = Config["kernel"]:"";



    // Base Selection
    if (base!="")
    {
	Pkg::SetSelection(base);
    }

    // Addons
    if (size(addons) > 0 )
    {
	foreach(string s, addons, ``{
	    Pkg::SetSelection(s);
	});
    }

    packages = (list<string>) union(packages, post_packages);
    packages = add(packages, kernel);

    y2milestone("Selected packages: %1", packages);

    Pkg::DoProvide(packages);

    boolean ret = Pkg::ActivateSelections();

    Pkg::PkgSolve(false);

    return (ret);
}


/**
  * getRpmPath
  * get physical rpm location
  * @return: package path
  */
global define  string  getRpmPath( map package_data) ``{

    integer srcid = package_data["srcid"]:-1;
    map s = meta[srcid]:$[];
    map pd = s["productData"]:$[];
    map md = s["mediaData"]:$[];
    string dataDir = pd["datadir"]:"./suse";
    string url = md["url"]:"";
    map urlmap = URL::Parse(url);
    string ArchLocation =  sformat("%1/%2", package_data["arch"]:"noarch", package_data["location"]:"norpm.rpm");
    string FullPath =  urlmap["path"]:"" + "/" + dataDir + "/" + ArchLocation;
    return FullPath;
};


global define boolean verifyDestination() ``{
    if ((integer)SCR::Read(.target.size, Config["iso-directory"]:"") > 0 ) { // its a file!
        Report::Error(_("Destination directory exists or is a file."));
        return false;
    }
    return true;
}

/**
 * Check if selected packages are available
 * @return string error message
 */
global define string checkPackageAvail() ``{

    string error_msg = "";

    Progress::Title(_("Checking for package availability..."));

    list selectedPackages = Pkg::GetPackages (`selected , true);

    list failed = [];
    toCopy = [];
    foreach(string package, selectedPackages, ``{

	map package_data = Pkg::PkgProperties(package);
	string FullPath = getRpmPath(package_data);
	y2debug("Checking for package: %1 ",  FullPath);
	integer package_size = (integer)SCR::Read(.target.size, FullPath);
	if (package_size == -1 )
	{
	    failed = add (failed, FullPath);
	}
	else
	{
	    string arch =  package_data["arch"]:"noarch";
	    toCopy = add(toCopy, $["path": FullPath, "name": package, "arch":  arch ]);
	}
    });
    CDCreator::missing_packages = failed;
    if (size(failed) > 0 )
    {
	integer num = size(failed);
	error_msg = sformat(_("%1 package not available.", "%1 packages not available.", num), num);
    }

    return error_msg;
}





/**
 * CopyPackages()
 * Copy selected package to target tree
 */
global define boolean CopyPackages(integer id) ``{

    string datadir  = meta[id,"productData", "datadir"]:"./suse";
    foreach(map package, toCopy, ``{

	Progress::Title(sformat(_("Copying %1"), package["name"]:"..." ));
	Progress::NextStep();
	string dir = Config["iso-directory"]:"" + "/" +  Config["name"]:"" + "/" +  datadir + "/" + package["arch"]:"";

	if (size((list)SCR::Read(.target.dir, dir)) == nil )
	{
	    SCR::Execute(.target.mkdir , dir);
	}

	string cpCmd = sformat("cp %1 %2", package["path"]:"", dir );

	y2debug("%1", cpCmd);

	any ret = SCR::Execute (.target.bash, cpCmd);

    });

    return true;
}



global define boolean readControlFile(string filename) ``{

    import "Profile";
    if (!Profile::ReadXML(filename))
    {
        Report::Error(_("Error reading control file"));
        return false;
    }
    map software = Profile::current["install", "software"]:$[];
    Config["base"] = software["base"]:"";
    Config["addons"] = software["addons"]:[];
    Config["packages"] = software["packages"]:[];
    return true;
}

/**
 * Constructor
 */
global define void CDCreator() ``{
    configSetup();
}


/* EOF */
}
