/**
 * File:	modules/CDCreator.ycp
 * Package:	Configuration of cd-creator
 * Summary:	Data for configuration of cd-creator, input and output functions.
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 *
 * Representation of the configuration of cd-creator.
 * Input and output routines.
 */

{

module "CDCreator";
textdomain "cd-creator";

import "Progress";
import "Report";
import "Summary";
import "XML";




global map productData = $[];

global map mediaData = $[];

global map sourceData = $[];

global list missing_packages = [];

global list toCopy = [];

/* Local variables */

string skel_root = "";







/* Configuration Map */
global map Config = $[];

/* All Configurations */
global map Configs = $[];

/* Configuration Repository */
global string Rep = "/var/lib/YaST2/cd-creator";

/* Configuration file */
global string ConfigFile = Rep + "/cdcreator.xml";

/**
 * Abort function
 * return boolean return true if abort
 */
global block<boolean> AbortFunction = nil;

/**
 * Data was modified?
 */
global boolean modified = false;

global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Data was modified?
 * @return true if modified
 */
global define boolean Modified() ``{
    y2debug("modified=%1",modified);
    return modified;
};

include "cd-creator/routines.ycp";

// Settings: Define all variables needed for configuration of cd-creator
// TODO FIXME: Define all the variables necessary to hold
// TODO FIXME: the configuration here (with the appropriate
// TODO FIXME: description)
// TODO FIXME: For example:
//   /**
//    * List of the configured cards.
//    */
//   list cards = [];
//
//   /**
//    * Some additional parameter needed for the configuration.
//    */
//   boolean additional_parameter = true;

/**
 * Read all cd-creator settings
 * @return true on success
 */
global define boolean Read() ``{

    /* CDCreator read dialog caption */
    string caption = _("Initializing CD-Creator Configuration");

    // TODO FIXME Set the right number of stages
    integer steps = 1;

    integer sl = 2;
    sleep(sl);

    // TODO FIXME Names of real stages
    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    // translators: progress stage 1/1
	    _("Read the configuration")
	], [
	    // translators: progress step 1/1
	    _("Reading the database..."),
	    // translators: progress finished
	    _("Finished")
	],
	""
    );

    // read database
    if(Abort()) return false;
    Progress::NextStage();

    map c = $[];
    if (SCR::Read(.target.size, ConfigFile) != -1 )
	c = XML::XMLToYCPFile(ConfigFile);
    list all = c["configurations"]:[];
    Configs = listmap (map i, all, ``{
	string name = i["name"]:"";
	return($[name: i]);
    });
    y2milestone("Configs: %1", Configs);

    // translators: error message
    if(false) Report::Error(_("Cannot read the configuration."));
    sleep(sl);


    if(Abort()) return false;
    // translators: progress finished
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}



/**
 * Prepare map for writing  into XML
 * @return lists of configurations
 */
global define list PrepareConfigs() ``{

    list c = maplist(string k, map v, Configs, ``{
	return(v);
    });
    return (c);
}

/**
 * Write all cd-creator settings
 * @return true on success
 */
global define boolean Write() ``{

    /* CDCreator read dialog caption */
    string caption = _("Saving cd-creator Configuration");

    // TODO FIXME And set the right number of stages
    integer steps = 2;

    integer sl = 50;
    sleep(sl);

    // TODO FIXME Names of real stages
    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    // translators: progress stage 1/2
	    _("Write the settings"),
	    // translators: progress stage 2/2
	    _("Run SuSEconfig")
	], [
	    // translators: progress step 1/2
	    _("Writing the settings..."),
	    // translators: progress step 2/2
	    _("Running SuSEconfig..."),
	    // translators: progress finished
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();

    list c = PrepareConfigs();
    map xml = $["configurations": c];
    boolean ret = XML::YCPToXMLFile(`cdcreator, xml, ConfigFile);

    // translators: error message
    if(!ret) Report::Error (_("Cannot write settings."));


    // run SuSEconfig
    if(Abort()) return false;
    Progress::NextStage ();
    // translators: error message
    if(false) Report::Error (_("SuSEconfig script failed."));
    sleep(sl);

    if(Abort()) return false;
    // translators: progress finished
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Get all cd-creator settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global define boolean Import (map settings) ``{
    // TODO FIXME: your code here (fill the above mentioned variables)...
    sleep(3000);
    return true;
}

/**
 * Dump the cd-creator settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global define map Export () ``{
    // TODO FIXME: your code here (return the above mentioned variables)...
    sleep(3000);
    return $[];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global define list Summary() ``{
    // TODO FIXME: your code here...
    // translators: Configuration summary text for autoyast
    return [ _("Configuration summary ..."), [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global define list Overview() ``{
    y2milestone("Configs: %1", Configs);
    list overview = maplist(string name , map cfg, Configs , ``{
	return(`item(`id(name), name, cfg["source"]:""));
    });
    return overview;
}



/**
 * Return contents of isolinux.cfg from the given source
 * @return string with contents of file.
 */
global define string Readisolinux() ``{

    string isolinux = Config["bootconfig"]:"";
    if (isolinux != "") {
		return isolinux;
	}

    string isolinux_path = sformat("%1/boot/loader/isolinux.cfg", Config["source"]:"" );
    if (SCR::Read(.target.size, isolinux_path) != -1 )
	isolinux = (string)SCR::Read(.target.string, isolinux_path );

    return isolinux;
}

/**
 * Create XML Configuration
 */
global define void configSetup()
    ``{
    map doc = $[];
    doc["listEntries"] =
	$[
	  "packages":"package",
	  "addons":"addon",
	  "configurations": "config"
	];
    doc["cdataSections"] = ["bootconfig"];
    doc["rootElement"] = "cd-creator";
    doc["systemID"] = "/usr/share/autoinstall/dtd/cd-creator.dtd";
    doc["nameSpace"] = "http://www.suse.com/1.0/yast2ns";
    doc["typeNamespace"] = "http://www.suse.com/1.0/configns";
    XML::xmlCreateDoc(`cdcreator, doc);
    return;
}


/**
 * Create Skeleton
 *
 */
global define boolean  CreateSkeleton () ``{

    list commands = [];
    integer ret = 0;
    boolean success = true;
    boolean savespace = Config["savespace"]:false;

    // Create skeleton directory
    skel_root = sformat("%1/%2", Config["iso-directory"]:"", Config["name"]:"");
    SCR::Execute(.target.mkdir, skel_root);


    string descrDir = productData["descrdir"]:"suse/setup/descr";
    string dataDir  = productData["datadir"]:"./suse";

    success = (boolean)SCR::Execute(.target.mkdir, sformat("%1/%2", skel_root, dataDir));
    if (!success)
	return false;

    commands= add(commands, sformat("/bin/mkdir -p %1/boot", skel_root));
    commands= add(commands, sformat("/bin/mkdir -p %1/boot/loader", skel_root));
    commands= add(commands, sformat("/bin/mkdir -p   %1//%2",  skel_root, descrDir));

    if (savespace)
    {
	// Installation, rescue images
	commands= add(commands, sformat("/bin/cp  %1/boot/root %2/boot", Config["source"]:"", skel_root));
	commands= add(commands, sformat("/bin/cp  %1/boot/rescue %2/boot", Config["source"]:"", skel_root));

	// Loader, x86 specific
	commands= add(commands, sformat("/bin/cp  %1/boot/loader/* %2/boot/loader", Config["source"]:"", skel_root));
	commands= add(commands, sformat("/bin/cp  %1/content %2", Config["source"]:"", skel_root));

    }
    else
    {
	// Copy all the contents of /boot
	commands= add(commands, sformat("/bin/cp -a  %1/boot %2", Config["source"]:"", skel_root));
	commands= add(commands, sformat("/bin/cp  %1/* %2", Config["source"]:"", skel_root));
    }
    // Descriptions, Selections and package databases
    commands= add(commands,
		  sformat("/bin/cp -a %1/%2/* %3/%4",
			  Config["source"]:"",
			  descrDir,
			  skel_root,
			  descrDir)
		  );

    // Prepare media files
    commands= add(commands, sformat("/bin/cp -a %1/media.1  %2", Config["source"]:"", skel_root));
    commands= add(commands, sformat("/usr/bin/head -n 2 %1/media.1/media  >   %2/media.1/media.tmp && mv %2/media.1/media.tmp %2/media.1/media",  skel_root, skel_root));


    // Media nr.
    integer count = 1;

    commands= add(commands, sformat("/bin/echo %1 >> %2/media.1/media ", count,  skel_root));

    foreach (string c, commands, ``{
	ret = (integer)SCR::Execute (.target.bash, c);
	if (ret != 0)
	{
	    success= false;
	}
    });
    if (!success)
	return false;

    /**

    list archdirs = productData["architectures"]:["i686", "i586", "i486", "i386", "noarch"];

    foreach(string dir, archdirs, ``{
	string dirname =  sformat("%1/skeleton/%2/%3", skel_root, dataDir, dir);
	SCR::Execute (.target.mkdir, dirname);
    });
    **/

    return success;
}


/**
 * CopyMiscFiles
 * Copy other files to directory tree
 */
global define boolean CopyMiscFiles() ``{

    string cpCmd = sformat("cp /usr/share/autoinstall/isolinux.cfg %1/boot/loader", skel_root);
    SCR::Execute (.target.bash, cpCmd);
    cpCmd = sformat("cp /usr/share/autoinstall/message %1/boot/loader", skel_root);
    SCR::Execute (.target.bash, cpCmd);
    cpCmd = sformat("cp /usr/share/autoinstall/options.msg %1/boot/loader", skel_root);
    SCR::Execute (.target.bash, cpCmd);


    return true;
}



/**
 * Enable source and get source meta data
 * @return true on success
 */
global define boolean EnableSource() ``{

    string dir = Config["source"]:"";
    list ids = Pkg::SourceStartCache(true);
    if (size(ids) == 0 )
	return false;

    list sources = [];
    foreach(integer i , ids, ``{
	map media = Pkg::SourceMediaData(i);
	string tmp =  sformat("dir://%1", dir);
	if (media["url"]:"" == tmp )
	{
	    productData = Pkg::SourceProductData(i);
	    mediaData = Pkg::SourceMediaData(i);
	    sourceData	= Pkg::SourceGeneralData(i);
	}
    });

    return true;
}


/**
 * Get all possible sources
 * @return available enabled sources list for widget
 */
global define list GetDirSources(string source) ``{
    import "URL";
    list ids = Pkg::SourceStartCache(true);
    list sources = [];
    foreach(integer i , ids, ``{
        map prod = Pkg::SourceProductData(i);
        map media = Pkg::SourceMediaData(i);
	map url = URL::Parse(media["url"]:"");
	if (url["scheme"]:"" == "dir")
	{
	    boolean selected = (source == url["path"]:"");
	    sources = add(sources, `item(`id(url["path"]:""), url["path"]:"", selected));

	}
    });

    return sources;
}



/**
 * Set packages to be copies to iso image tree
 * @return void
 */
global define boolean setPackages() ``{
    string base = Config["base"]:"";
    list<string> addons = Config["addons"]:[];
    list<string> packages  = Config["packages"]:[];
    list<string> post_packages  = Config["post-packages"]:[];
    string kernel = Config["kernel"]:"";



    // Base Selection
    if (base!="")
    {
	Pkg::SetSelection(base);
    }

    // Addons
    if (size(addons) > 0 )
    {
	foreach(string s, addons, ``{
	    Pkg::SetSelection(s);
	});
    }

    packages = (list<string>) union(packages, post_packages);
    packages = add(packages, kernel);

    y2milestone("Selected packages: %1", packages);

    Pkg::DoProvide(packages);

    boolean ret = Pkg::ActivateSelections();

    Pkg::PkgSolve(false);

    return (ret);
}


/**
  * getRpmPath
  * get physical rpm location
  * @return: package path
  */
global define  string  getRpmPath(string package) ``{

    string dataDir = productData["datadir"]:"./suse";

    list tok = splitstring( package , " ");

    string PkgLocation =  Pkg::PkgLocation(tok[0]:"");
    y2debug("Location: %1", PkgLocation );

    string ArchLocation = tok[3]:"noarch" + "/" + PkgLocation;
    string FullPath =  Config["source"]:"" + "/" + dataDir + "/" + ArchLocation;

    return FullPath;
};


/**
 * Check if selected packages are available
 */
global define string checkPackageAvail() ``{

    string descrDir	= productData["descrdir"]:"suse/setup/descr";
    string dataDir	= productData["datadir"]:"./suse";
    string error_msg = "";

    Progress::Title(_("Checking for package availability..."));

    list selectedPackages = Pkg::GetPackages (`selected , false);

    list failed = [];
    toCopy = [];
    foreach(string package, selectedPackages, ``{

	list tok = splitstring( package , " ");
	string FullPath = getRpmPath(package);
	y2debug("Checking for package: %1 ",  FullPath);
	integer package_size = (integer)SCR::Read(.target.size, FullPath);
	if (package_size == -1 )
	{
	    failed = add (failed, FullPath);
	}
	else {
	    toCopy = add(toCopy, $["path": FullPath, "name": tok[0]:"", "arch": tok[3]:"" ]);
	}
    });
    CDCreator::missing_packages = failed;
    if (size(failed) > 0 )
    {
	integer num = size(failed);
	error_msg = sformat(_("%1 package not available.", "%1 packages not available.", num), num);
    }

    return error_msg;
}





/**
 * CopyPackages()
 * Copy selected package to target tree
 */
global define boolean CopyPackages() ``{

    string datadir	= productData["datadir"]:"./suse";
    foreach(map package, toCopy, ``{

	Progress::Title(sformat(_("Copying %1"), package["name"]:"..." ));
	Progress::NextStep();
	string dir = Config["iso-directory"]:"" + "/" +  Config["name"]:"" + "/" +  datadir + "/" + package["arch"]:"";

	if (size((list)SCR::Read(.target.dir, dir)) == nil )
	{
	    SCR::Execute(.target.mkdir , dir);
	}

	string cpCmd = sformat("cp %1 %2", package["path"]:"", dir );

	y2debug("%1", cpCmd);

	any ret = SCR::Execute (.target.bash, cpCmd);

    });

    return true;

}



/**
 * Constructor
 */
global define void CDCreator() ``{
    configSetup();
}


/* EOF */
}
