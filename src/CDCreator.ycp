/**
 * File:	modules/CDCreator.ycp
 * Package:	Configuration of cd-creator
 * Summary:	Data for configuration of cd-creator, input and output functions.
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 *
 * Representation of the configuration of cd-creator.
 * Input and output routines.
 */

{

module "CDCreator";
textdomain "cd-creator";

import "Progress";
import "Report";
import "Summary";
import "XML";
import "URL";
import "Profile";
import "Misc";
import "Directory";
import "Profile";
import "AutoinstSoftware";
import "Arch";
import "PackageAI";
import "String";
import "GPG";
import "GPGWidgets";


global define void enableSources();


list<integer> old_enabled = [];


global string AYRepository = "";

global map meta = $[];
global map meta_local = $[];

global list<string> missing_packages = [];

global list<map> toCopy = [];

/* Local variables */

global string skel_root = "";


global boolean profile_parsed = false;


/* Configuration Map */
global map<string, any> Config = $[];

/* All Configurations */
global map<string, map<string, any> > Configs = $[];

/* Configuration Repository */
global string Rep = "/var/lib/YaST2/cd-creator";

/* Configuration file */
global string ConfigFile = Rep + "/cdcreator.xml";

/**
 * Abort function
 * return boolean return true if abort
 */
global block<boolean> AbortFunction = nil;

/**
 * Data was modified?
 */
global boolean modified = false;

global boolean proposal_valid = false;


/**
 * Data was modified?
 * @return true if modified
 */
global define boolean Modified() ``{
    y2debug("modified=%1",modified);
    return modified;
};

include "cd-creator/routines.ycp";

global define list<integer> UrlToId(list<string> urls)
{
    // all sources
    list<integer> all = Pkg::SourceGetCurrent(false);

    list<integer> sources = maplist(string url , urls,
    {
	integer id = -1;
	foreach (integer i, all,
	{
	    map generalData = Pkg::SourceGeneralData(i);
	    if (generalData["url"]:"" == url)
	    {
		id = i;
		break;
	    }
	});

	return id;
    });

    return sources;
}


map ReadContentFile(string content) {

    map contentmap = (map)SCR::Read(.content_file, content);
    return contentmap;
}

/**
 * Read all cd-creator settings
 * @return true on success
 */
global define boolean Read() ``{

    /* CDCreator read dialog caption */
    string caption = _("Initializing CD Creator Configuration");

    integer steps = 1;

    integer sl = 2;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    // translators: progress stage 1/1
	    _("Read the configuration")
	], [
	    // translators: progress step 1/1
	    _("Reading the database..."),
	    // translators: progress finished
	    _("Finished")
	],
	""
    );

    // read database
    if(Abort()) return false;
    Progress::NextStage();

    map c = $[];
    if (SCR::Read(.target.size, ConfigFile) != -1 )
    {
	c = XML::XMLToYCPFile(ConfigFile);
    }
    list<map<string, any> > all = c["configurations"]:[];
    Configs = listmap (map<string,any> i, all, ``{
	string name = i["name"]:"";
	return($[name: i]);
    });
    y2milestone("Configs: %1", Configs);

    // translators: error message
    if(false) Report::Error(_("Cannot read the configuration."));
    sleep(sl);


    if(Abort()) return false;
    // translators: progress finished
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}



/**
 * Prepare map for writing  into XML
 * @return lists of configurations
 */
global define list PrepareConfigs() ``{

    list c = maplist(string k, map v, Configs, ``{
	return(v);
    });
    return (c);
}

/**
 * Write all cd-creator settings
 * @return true on success
 */
global define boolean Write() ``{

    /* CDCreator read dialog caption */
    string caption = _("Saving CD Creator Configuration");

    integer steps = 2;

    integer sl = 50;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    // translators: progress stage 1/2
	    _("Write the settings"),
	], [
	    // translators: progress step 1/1
	    _("Writing the settings..."),
	    // translators: progress finished
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();

    list c = PrepareConfigs();
    map xml = $["configurations": c];

    if (SCR::Read(.target.size, Rep) < 0)
    {
	SCR::Execute(.target.bash, "mkdir -p " + Rep);
    }

    y2milestone("Writing XML file %1: %2", ConfigFile, xml);
    boolean ret = XML::YCPToXMLFile(`cdcreator, xml, ConfigFile);

    // translators: error message
    if(!ret) Report::Error (_("Error while writing settings."));


    // run SuSEconfig
    if(Abort()) return false;
    Progress::NextStage ();
    // translators: error message
    if(false) Report::Error (_("SuSEconfig script failed."));
    sleep(sl);

    if(Abort()) return false;
    // translators: progress finished
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Get all cd-creator settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global define boolean Import (map settings) ``{
    return true;
}

/**
 * Dump the cd-creator settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global define map Export () ``{
    return $[];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global define list Summary() ``{
    // translators: Configuration summary text for autoyast
    return [ _("Configuration summary ..."), [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global define list Overview() ``{
    y2milestone("Configs: %1", Configs);
    list overview = maplist(string name , map cfg, Configs , ``{
            string isofile = cfg["iso-directory"]:"" + "/" +  cfg["isofile"]:"";
            if (SCR::Read(.target.size, isofile) < 0 )
                isofile = _("No Files");
	return(`item(`id(name), name, cfg["product"]:"", isofile, cfg["gpg_key"]:""));
    });
    return overview;
}


/**
 * Get media urls
 * @param list list of ids
 * @return list list of urls
 */
global define list getSourceURLs ( list<integer> ids ) ``{
    list<string> urls = maplist(integer i , ids, ``{
	map media = Pkg::SourceMediaData(i);

	return(media["url"]:"");
    });

    return urls;
}


/**
 * get path to directory source
 * @param string url
 * @return string path
 */
global define string getSourceDir(string url) ``{
    map urlsegs = URL::Parse(url);
    return(urlsegs["path"]:"");
}

/**
 * Return contents of isolinux.cfg from the given source
 * @return string with contents of file.
 */
global define string Readisolinux() ``{

    string bootconfig = Config["bootconfig"]:"";
    if (bootconfig != "")
    {
	return bootconfig;
    }

    string bootconfig_path = "";
    if (Config["pkgtype"]:"" == "autoyast")
    {
        bootconfig_path = sformat("%1/cd-creator/isolinux.cfg",
                Directory::datadir);
    }
    else
    {
        string dir = getSourceDir(Config["sources", 0]:"" );
	string arch = Arch::architecture();
        bootconfig_path = sformat("%1/boot/%2/loader/isolinux.cfg", dir, arch);

	if (SCR::Read(.target.size, bootconfig_path) < 0)
	{
	    // try the old path as a fallback
	    bootconfig_path = sformat("%1/boot/loader/isolinux.cfg", dir );
	}
    }
    if (SCR::Read(.target.size, bootconfig_path) != -1 )
          bootconfig = (string)SCR::Read(.target.string, bootconfig_path );

    // replace tabs by spaces in ncurses UI (workaround for #142509)
    if (UI::GetDisplayInfo()["TextMode"]:false == true)
    {
	// tab -> 8 spaces
	bootconfig = String::Replace(bootconfig, "\t", "        ");
    }

    return bootconfig;
}

/**
 * Create XML Configuration
 */
global define void configSetup()
    ``{
    map doc = $[];
    doc["listEntries"] =
	$[
	  "packages":"package",
	  "addons":"addon",
	  "configurations": "config"
	];
    doc["cdataSections"] = ["bootconfig"];
    doc["rootElement"] = "cd-creator";
    doc["systemID"] = "/usr/share/autoinstall/dtd/cd-creator.dtd";
    doc["nameSpace"] = "http://www.suse.com/1.0/yast2ns";
    doc["typeNamespace"] = "http://www.suse.com/1.0/configns";
    XML::xmlCreateDoc(`cdcreator, doc);
    return;
}

boolean ExportPublicKey(string keyid, string dir)
{
    // export the public key
    boolean ret = GPG::ExportAsciiPublicKey(keyid, dir + "/content.key");

    // export the public key
    ret = ret && GPG::ExportAsciiPublicKey(keyid, dir + "/media.1/products.key");

    // export the public key
    ret = ret && GPG::ExportAsciiPublicKey(keyid, dir + sformat("/gpg-pubkey-%1.asc", tolower(keyid)));

    y2milestone("exported public key %1: %2", keyid, ret);
    return ret;
}

boolean SignSourceFiles(string keyid, string dir, string passphrase)
{
    // sign the content file
    boolean ret = GPG::SignDetached(keyid, dir + "/content", passphrase);

    // sign the product file
    ret = ret && GPG::SignDetached(keyid, dir + "/media.1/products", passphrase);

    y2milestone("Signed source: %1", ret);
    return ret;
}

string SHA1Meta(string dir, string product_dir)
{
    // generate new sha1 sums for files in descr subdirectory
    // remove './' from the file names, ignore directory.yast file, sort the output
    string command = sformat("(cd '%1/%2' && find . -type f -exec sha1sum \\{\\} \\; | sed -e 's#^\\(.\\{40\\}\\)  ./#META SHA1 \\1  #' | grep -v '^.\\{40\\}  directory.yast$' | LC_ALL=C sort -k 2)", String::Quote(dir), String::Quote(product_dir));

    y2milestone("Generating SHA1 sums: %1", command);

    // execute the command
    map ret = (map)SCR::Execute(.target.bash_output, command);
    y2milestone("Result: %1", ret);
    string meta_sha1 = ret["stdout"]:"";

    return meta_sha1;
}

string SHA1Key(string dir)
{
    // generate new sha1 sums for files in descr subdirectory
    // remove './' from the file names, ignore directory.yast file, sort the output
    string command = sformat("(cd '%1' && find . -type f -name 'gpg-pubkey-*.asc' -exec sha1sum \\{\\} \\; | sed -e 's#^\\(.\\{40\\}\\)  ./#KEY SHA1 \\1  #' | LC_ALL=C sort -k 2)", String::Quote(dir));

    y2milestone("Generating SHA1 key sums: %1", command);

    // execute the command
    map ret = (map)SCR::Execute(.target.bash_output, command);
    y2milestone("Result: %1", ret);
    string key_sha1 = ret["stdout"]:"";

    return key_sha1;
}

global boolean UpdateContentFile(string dir, string prod_dir)
{
    boolean ret = true;

    string meta_sha1 = SHA1Meta(dir, prod_dir);
    string key_sha1 = SHA1Key(dir);

    string command = sformat("/usr/bin/grep -v -e '^KEY ' -e '^META ' %1/content", dir);
    map out = (map)SCR::Execute(.target.bash_output, command);
    if (out["exit"]:-1 != 0)
    {
	return false;
    }

    string read_content = out["stdout"]:"";
    y2internal("content file: %1", read_content);

    // add trailing new line char if it's missing
    if (size(read_content) > 0 && substring(read_content, size(read_content) - 1, 1) != "\n")
    {
	read_content = read_content + "\n";
    }

    // add trailing new line char if it's missing
    if (size(meta_sha1) > 0 && substring(meta_sha1, size(meta_sha1) - 1, 1) != "\n")
    {
	meta_sha1 = meta_sha1 + "\n";
    }

    // concatenate the meta and the key sums
    read_content = read_content + meta_sha1 + key_sha1;

    // write the file
    ret = SCR::Write(.target.string, dir + "/content", read_content);
    y2milestone("Updated content file %1: %2", dir + "/content", ret);

    return ret;
}

global boolean UpdateMD5File(string directory)
{
    boolean ret = true;
    string md5file = directory + "/MD5SUMS";
    string command = "";

    if (SCR::Read(.target.size, md5file) >= 0)
    {
	command = "rm -f " + md5file;
	y2milestone("removing old MD5SUMS file: %1", md5file);
	ret = SCR::Execute(.target.bash, command) == 0;

	if (!ret)
	{
	    y2error("Cannot remove the old MD5SUMS file");
	    return false;
	}
    }

    command = sformat("cd %1 && md5sum * > MD5SUMS", directory);
    ret = SCR::Execute(.target.bash, command) == 0;

    y2milestone("MD5SUMS updated: %1", ret);
    return ret;
}

/**
 * Create Skeleton
 * @return boolean true on success
 */
global define boolean  CreateSkeleton () ``{

    list<string> commands = [];
    integer ret = 0;
    boolean success = true;
    boolean savespace = Config["savespace"]:false;
    boolean sp = false;
    string sles_path = "";
    string descr_dir = "";
    string arch = Arch::architecture();

    y2milestone("Config: %1", Config);

    // Create skeleton directory
    skel_root = sformat("%1/%2", Config["iso-directory"]:"", Config["name"]:"");
    SCR::Execute(.target.mkdir, skel_root);

    commands= add(commands, sformat("/bin/mkdir -p %1/boot/%2", skel_root, arch));

    list<integer> enabled = Pkg::SourceGetCurrent(true);
    if (size(enabled) == 0 )
        return false;
    y2milestone("enabled sources: %1", enabled );
    string source = "";
    string descrDir = "";
    string dataDir = "";

    if (Arch::i386() || Arch::x86_64())
    {
	if (Config["code10"]:false)
	{
	    commands= add(commands, sformat("/bin/mkdir -p %1/boot/%2/loader", skel_root, arch));
	}
	else
	{
	    commands= add(commands, sformat("/bin/mkdir -p %1/boot/loader", skel_root));
	}
    }
    else if (Arch::ppc() || Arch::ppc64())
    {
	commands= add(commands, sformat("/bin/mkdir -p %1/etc", skel_root));
	commands= add(commands, sformat("/bin/mkdir -p %1/ppc", skel_root));
	commands= add(commands, sformat("/bin/mkdir -p %1/suseboot", skel_root));
    }

    foreach(integer id, enabled, ``{
	
	map this_source = meta[id]:$[];
	source   = this_source["path"]:"";
	meta_local = ReadContentFile(source + "/content");

	if (source == "")
	    return false;

	y2milestone("source: %1", source);
	descr_dir = this_source["productData","descrdir"]:"suse/setup/descr";

	y2debug("content: %1", meta_local);
	if (this_source["productData","baseproductname"]:"" != "" &&
	    issubstring(meta_local["FLAGS"]:"", "SP"))
	{
	    y2milestone("Service pack detected");
	    y2debug("this source: %1", this_source );
	    descrDir = this_source["productData","descrdir"]:"suse/setup/descr";
	    dataDir  = this_source["productData", "datadir"]:"suse";
	    y2debug("source data: %1", this_source["sourceData", "url"]:"" );
	     // Service Pack
	    if (savespace)
	    {
		// Installation, rescue images
		if (Config["code10"]:false)
		{
		    commands= add(commands, sformat("/bin/cp  %1/boot/%3/rescue %2/boot/%3", source, skel_root, arch));
		}
		else
		{
		    commands= add(commands, sformat("/bin/cp  %1/boot/rescue %2/boot", source, skel_root));
		}
		// Loader, x86 specific
		if (Arch::i386() || Arch::x86_64())
		{
		    if (Config["code10"]:false)
		    {
			commands= add(commands, sformat("/bin/cp  %1/boot/%3/loader/* %2/boot/%3/loader", source, skel_root, arch));
			commands= add(commands, sformat("/bin/cp  %1/boot/%3/* %2/boot/%3", source, skel_root, arch));
		    }
		    else
		    {
			commands= add(commands, sformat("/bin/cp  %1/boot/loader/* %2/boot/loader", source, skel_root));
		    }
		}
		else if (Arch::ppc() || Arch::ppc64())
		{
		    commands= add(commands, sformat("/bin/cp -a %1/boot/* %2/boot/", source, skel_root));
		    commands= add(commands, sformat("/bin/cp %1/etc/* %2/etc/", source, skel_root));
		    commands= add(commands, sformat("/bin/cp %1/ppc/* %2/ppc/", source, skel_root));
		    commands= add(commands, sformat("/bin/cp %1/suseboot/* %2/suseboot/", source, skel_root));
		} else {
		    commands= add(commands, sformat("/bin/cp  %1/boot/* %2/boot/", source, skel_root));
		}
	    }
	    else
	    {
		// Copy all the contents of /boot
		commands= add(commands, sformat("/bin/cp -a  %1/boot/* %2/boot", source, skel_root));

		if (Arch::ppc() || Arch::ppc64())
		{
		    commands= add(commands, sformat("/bin/cp %1/ppc/* %2/ppc", source, skel_root));
		    commands= add(commands, sformat("/bin/cp %1/etc/* %2/etc", source, skel_root));
		    commands= add(commands, sformat("/bin/cp %1/suseboot/* %2/suseboot", source, skel_root));
		}
	    }
	    commands= add(commands, sformat("/bin/cp  %1/driverupdate %2/", source, skel_root));
	    // Descriptions, Selections and package databases
	    commands= add(commands,
			  sformat("/bin/cp -a %1/%2/* %3/%4",
				  source,
				  descrDir,
				  skel_root,
				  descrDir)
			  );
	    
	    sp = true;
	}
	else if  (this_source["productData","baseproductname"]:"" != "" )
	{
	    // SLES
	    y2milestone("SLES source detected");

	    sles_path = source;
	    y2milestone("this source: %1", this_source );
	    descrDir = this_source["productData","descrdir"]:"suse/setup/descr";
	    dataDir  = this_source["productData", "datadir"]:"suse";
	    y2debug("source data: %1", this_source["sourceData", "url"]:"" );
	    success = (boolean)SCR::Execute(.target.mkdir, sformat("%1/%2", skel_root, dataDir));
	    if (!success)
		return false;
	 
	    commands= add(commands, sformat("/bin/mkdir -p %1/%2",  skel_root, descrDir));	    

	    if (savespace)
	    {
		// Installation, rescue images
		if (Config["code10"]:false)
		{
		    commands= add(commands, sformat("/bin/cp  %1/boot/%3/root %2/boot/%3", source, skel_root, arch));
		    commands= add(commands, sformat("/bin/cp  %1/boot/%2/root.fonts %3/boot/%2", source, arch, skel_root));
		    commands= add(commands, sformat("/bin/cp  %1/boot/%3/rescue %2/boot/%3", source, skel_root, arch));
		}
		else
		{
		    commands= add(commands, sformat("/bin/cp  %1/boot/root %2/boot", source, skel_root));
		    commands= add(commands, sformat("/bin/cp  %1/boot/rescue %2/boot", source, skel_root));
		}

		commands= add(commands, sformat("/bin/cp  %1/content* %2", source, skel_root));
		commands= add(commands, sformat("/bin/cp  %1/control.xml %2", source, skel_root));
	    } else {
		if (Config["code10"]:false)
		{
		    commands= add(commands, sformat("/bin/cp  %1/boot/%3/root %2/boot/%3", source, skel_root, arch));
		}
		else
		{
		    commands= add(commands, sformat("/bin/cp  %1/boot/root %2/boot", source, skel_root));
		}

		// copy base files, skipped directories are reported as an error -> force success
		commands= add(commands, sformat("/bin/cp %1/* %2; exit 0", source, skel_root));
	    }

	    y2milestone("source: %1, descrDir: %2, skel_root: %3", source, descrDir, skel_root);
	    // Descriptions, Selections and package databases
	    commands= add(commands,
			  sformat("/bin/cp -a %1/%2/* %3/%4",
				  source,
				  descrDir,
				  skel_root,
				  descrDir)
			  );

	    // Prepare media files
	    commands= add(commands, sformat("/bin/cp -a %1/media.1  %2", source, skel_root));
	    commands= add(commands, sformat("/usr/bin/head -n 2 %1/media.1/media  >   %2/media.1/media.tmp && mv %2/media.1/media.tmp %2/media.1/media",  skel_root, skel_root));

	    
	}
	else
	{
	    // copy base files, skipped directories are reported as an error -> force success
	    commands= add(commands, sformat("/bin/cp %1/* %2; exit 0", source, skel_root));
	}
    });
    

    if (!sp)
    {
	y2milestone("NOT SP");

	if (sles_path != "")
	{
	    source = sles_path;
	}

	if (descrDir == "")
	{
	    descrDir = descr_dir;
	}

	if (dataDir == "")
	{
	    dataDir = String::FirstChunk(descr_dir, "/");

	    if (dataDir == "")
	    {
		dataDir = "suse";
	    }
	}

	if (savespace)
	{
	    // Installation, rescue images
	    if (Config["code10"]:false)
	    {
		commands= add(commands, sformat("/bin/cp  %1/boot/%2/rescue %3/boot/%2", source, arch, skel_root));
		commands= add(commands, sformat("/bin/cp  %1/boot/%2/root %3/boot/%2", source, arch, skel_root));
		commands= add(commands, sformat("/bin/cp  %1/boot/%2/root.fonts %3/boot/%2", source, arch, skel_root));
	    }
	    else
	    {
		commands= add(commands, sformat("/bin/cp  %1/boot/rescue %2/boot", source, skel_root));
	    }

	    // Loader, x86 specific
	    if (Arch::i386() || Arch::x86_64())
	    {
		if (Config["code10"]:false)
		{
		    commands= add(commands, sformat("/bin/cp  %1/boot/%3/loader/* %2/boot/%3/loader", source, skel_root, arch));
		    commands= add(commands, sformat("/bin/cp  %1/boot/* %2/boot/", source, skel_root));
		}
		else
		{
		    commands= add(commands, sformat("/bin/cp  %1/boot/loader/* %2/boot/loader", source, skel_root));
		}
	    } else {
		commands= add(commands, sformat("/bin/cp  %1/boot/* %2/boot/", source, skel_root));
	    }
	}
	else
	{
	    // Copy all the contents of /boot
	    commands= add(commands, sformat("/bin/cp -a  %1/boot/* %2/boot", source, skel_root));
		
	}	
    }

    // Descriptions, Selections and package databases
    commands= add(commands, sformat("/bin/mkdir -p %1/%2", skel_root, descrDir));
    commands= add(commands,
		  sformat("/bin/cp -a %1/%2/* %3/%4",
			  source,
			  descrDir,
			  skel_root,
			  descrDir)
		  );

    string slideDir = dataDir + "/setup/slide";
    if (!savespace)
    {
	y2milestone("slideDir: %1", slideDir);

	if (SCR::Read(.target.size, sformat("%1/%2", source, slideDir)) > 0)
	{
	    // copy slide show
	    commands= add(commands, sformat("/bin/mkdir -p %1/%2", skel_root, slideDir));
	    commands= add(commands,
			  sformat("/bin/cp -a %1/%2 %3/%4",
				  source,
				  slideDir,
				  skel_root,
				  slideDir)
			  );
	}
	else
	{
	    y2milestone("Slideshow is missing");
	    commands= add(commands, sformat("/bin/mkdir -p %1/%2", skel_root, slideDir));
	    commands= add(commands, sformat("> %1/%2/directory.yast", skel_root, slideDir));
	}
    }
    else
    {
	y2milestone("Save space - do not copy slideshow");
	commands= add(commands, sformat("/bin/mkdir -p %1/%2", skel_root, slideDir));
	commands= add(commands, sformat("> %1/%2/directory.yast", skel_root, slideDir));
    }

    y2milestone("source: %1, descrDir: %2, skel_root: %3", source, descrDir, skel_root);

    // Prepare media files
    commands= add(commands, sformat("/bin/cp -a %1/media.1  %2", source, skel_root));
    commands= add(commands, sformat("/usr/bin/head -n 2 %1/media.1/media  >   %2/media.1/media.tmp && mv %2/media.1/media.tmp %2/media.1/media",  skel_root, skel_root));


    // create a copy of the autoyast profile (the new profile accepts even unsigned source)
    string autoyast_copy = "";

    if (Config["profile"]:""!="")
    {
	string prof = Config["profile"]:"";

	if (!Profile::ReadXML(prof))
	{
	    Report::Error(_("Error reading control file."));
	}
	else
	{
	    y2internal("Current profile: %1", Profile::current);

	    if ( Profile::current["general", "signature-handling" ]:nil == nil)
	    {
		Profile::current["general", "signature-handling" ] = $[];
	    }

	    Profile::current["general", "signature-handling", "accept_unsigned_file"] = true;

	    // add prefix to the name
	    list<string> parts = splitstring(prof, "/");
	    parts[size(parts) - 1] = "install_"+ parts[size(parts) - 1]:"";
	    prof = mergestring(parts, "/");

	    boolean saved = Profile::Save(prof);
	    y2milestone("Modified profile saved to %1: %2", prof, saved);

	    if (saved)
	    {
		autoyast_copy = prof;
	    }
	    else
	    {
		// saving to the original location has failed, save copy to tmpdir
		string tmpdir = (string)SCR::Read(.target.tmpdir);
		prof = tmpdir + "/cd-creator-autoyast_profile.xml";

		// save the copy
		saved = Profile::Save(prof);

		y2milestone("Copy of the profile saved to %1: %2", prof, saved);
		if (saved)
		{
		    autoyast_copy = prof;
		}
	    }
	}
    }

    // copy autoyast profile
    if (Config["profile"]:""!="" && Config["copy_profile"]:false)
    {
	if (autoyast_copy != "")
	{
	    // save the original file and the copy
	    commands = add(commands, sformat("/bin/cp %1 %2/autoinst.xml", autoyast_copy, skel_root));
	    commands = add(commands, sformat("/bin/cp %1 %2/autoinst.orig.xml", Config["profile"]:"", skel_root));
	}
	else
	{
	    // save the original file (copy is not available)
	    commands = add(commands, sformat("/bin/cp %1 %2/autoinst.xml", Config["profile"]:"", skel_root));
	}
    }

    // Media nr.
    integer count = 1;

    commands = add(commands, sformat("/bin/echo %1 >> %2/media.1/media ", count,  skel_root));

    // make the source digitally unsigned (because signed descr/packages file has been modified)
    if (Config["code10"]:false)
    {
	// remove the key and the checksum
	commands= add(commands, sformat("/bin/rm %1/content.asc %1/content.key", skel_root));
	// remove the meta information from content file
	commands= add(commands, sformat("/usr/bin/grep -v -e '^KEY ' -e '^META ' %1/content > %1/content.new", skel_root));
	commands= add(commands, sformat("/bin/mv %1/content.new %1/content", skel_root));

	// recreate the index file
	commands= add(commands, sformat("/bin/rm -f %1/directory.yast; cd %1; ls | grep -v -e '^\\.$' -e '^\\.\\.$' > %1/directory.yast", skel_root));

	// remove unused patterns, p
	if (Config["type"]:`unknown == `patterns)
	{
	    list<string> used_patterns = Config["addons"]:[];

	    if (Config["base"]:"" != "")
	    {
		used_patterns = prepend(used_patterns, Config["base"]:"");
	    }

	    list<string> available_patterns = Pkg::GetPatterns(`available, "");
	    list<string> unused_patterns = [];
	    y2milestone("used_patterns: %1", used_patterns);
	    y2milestone("available_patterns: %1", available_patterns);

	    // get unused patterns
	    foreach(string pat, available_patterns,
		{
		    if (!contains(used_patterns, pat))
		    {
			unused_patterns = add(unused_patterns, pat);
		    }
		}
	    );

	    y2milestone("Unused patterns: %1", unused_patterns);

	    foreach(string unused_pat, unused_patterns,
		{
		    list<map> pat_infos = Pkg::ResolvableProperties(unused_pat, `pattern, "");

		    foreach(map pat_info, pat_infos,
			{
			    // remove the pattern
			    commands= add(commands, sformat("/bin/rm %1/%5/%2-%3.%4.pat", skel_root, unused_pat, pat_info["version"]:"", pat_info["arch"]:"", descrDir));
			}
		    );
		}
	    );

	    if (size(unused_patterns) > 0)
	    {
		// regenerate directory.yast and patterns file
		commands= add(commands, sformat("/bin/rm -f %1/%2/directory.yast; cd %1/%2; ls | grep -v -e '^\\.$' -e '^\\.\\.$' > %1/%2/directory.yast", skel_root, descrDir));
		commands= add(commands, sformat("cd %1/%2; ls *.pat > %1/%2/patterns", skel_root, descrDir));
	    }
	}
    }

    y2milestone("all commands: %1", mergestring(commands, "\n"));

    foreach (string c, commands, ``{
        y2milestone("executing: %1", c);
	success = success && ((integer)SCR::Execute (.target.bash, c) == 0);
	y2milestone("success: %1", success);
    });

    // update MD5SUMS file
    success = success && UpdateMD5File(sformat("%1/%2", skel_root, descrDir));

    return success;
}

// see http://en.opensuse.org/Secure_Installation_Sources
boolean InsertKeyToInitrd(string gpg_key, string initrd_file)
{
    y2internal("Adding GPG key %1 to initrd %2", gpg_key, initrd_file);
    // initrd is cpio.gz archive

    list<string> parts = splitstring(initrd_file, "/");
    if (size(parts) > 1)
    {
	// remove the last element
	parts = remove(parts, size(parts) - 1);
    }
    string base = mergestring(parts, "/");

    boolean ret = GPG::ExportPublicKey(gpg_key, sformat("%1/gpg-%2.gpg", base, gpg_key));
    if (!ret) return false;

    // uncompress the archive and add the GPG key
    string command = sformat("cd '%1' && gunzip < '%2' > '%2.cpio' && echo 'gpg-%3.gpg' | cpio -o -H newc -A -F '%2.cpio'", String::Quote(base), String::Quote(initrd_file), gpg_key);
    y2milestone("command: %1", command);

    map out = (map)SCR::Execute(.target.bash_output, command);
    y2milestone("output: %1", out);
    ret = out["exit"]:-1 == 0;
    if (!ret) return false;

    // compress the archive, remove the temporary files
    command = sformat("gzip --best < '%1.cpio' > '%1' && rm -f '%1.cpio' '%2/gpg-%3.gpg'", String::Quote(initrd_file), String::Quote(base), gpg_key);
    y2milestone("command: %1", command);

    out = (map)SCR::Execute(.target.bash_output, command);
    y2milestone("output: %1", out);
    ret = out["exit"]:-1 == 0;

    return ret;
}

global boolean InsertKeyToInitrds(string gpg_key, string base_dir)
{
    // get initrd list
    string command = "";
    map out = $[];
    string find_output = "";

    if (SCR::Read(.target.size, base_dir + "/boot") >= 0)
    {
	y2milestone("Searching for 'initrd' in %1/boot...", base_dir);
	command = sformat("cd '%1' && find boot -type f -name 'initrd'", String::Quote(base_dir));
	out = (map)SCR::Execute(.target.bash_output, command);
	find_output = out["stdout"]:"";
    }

    if (SCR::Read(.target.size, base_dir + "/suseboot") >= 0)
    {
	y2milestone("Searching for 'initrd*' in %1/suseboot...", base_dir);
	command = sformat("cd '%1' && find suseboot -type f -name 'initrd*'", String::Quote(base_dir));
	out = (map)SCR::Execute(.target.bash_output, command);
	find_output = find_output + out["stdout"]:"";
    }

    list<string> initrds = splitstring(find_output, "\n");
    // remove empty strings
    initrds = filter(string initrd, initrds, {return initrd != "";});
    y2milestone("Found initrds: %1", initrds);

    boolean ret = true;
    foreach(string initrd, initrds,
	{
	    boolean inserted = InsertKeyToInitrd(gpg_key, base_dir + "/" + initrd);

	    if (!inserted)
	    {
		Report::Error(sformat(_("Could not add GPG key %1 to initrd\n%2"), gpg_key, initrd));
		ret = false;
	    }
	}
    );

    return ret;
}

global boolean SignSourceStep()
{
    boolean success = true;

    // sign the files
    string gpg_key = Config["gpg_key"]:"";
    if (gpg_key != "")
    {
	boolean signed = false;

	while (!signed)
	{
	    string passphrase = GPGWidgets::AskPassphrasePopup(gpg_key);

	    if (passphrase == nil)
	    {
		// aborted
		break;
	    }

	    // export the key
	    success = success && ExportPublicKey(gpg_key, skel_root);
	    // update SHA1 sums
	    success = success && UpdateContentFile(skel_root, "suse/setup/descr");
	    // sign the source
	    signed = SignSourceFiles(gpg_key, skel_root, passphrase);

	    // yes/no popup: error message
	    if (!signed && !Popup::YesNo(_("Error: Could not digitally sign the source.\nTry it again?")))
	    {
		break;
	    }

	    if (signed)
	    {
		// update directory.yast file
		string command = sformat("/bin/rm -f '%1/directory.yast'; cd '%1'; ls | grep -v -e '^\\.$' -e '^\\.\\.$' > '%1/directory.yast'", String::Quote(skel_root));
		y2milestone("Updating %1/directory.yast ...", skel_root);
		integer updated = (integer)SCR::Execute(.target.bash, command);
		y2milestone("Updated: %1", updated == 0);
		success = success && updated == 0;
	    }
	}

	success = success && signed;

	success = success && InsertKeyToInitrds(gpg_key, skel_root);
    }

    y2milestone("Source signed: %1", success);
    return success;
}


/**
 * CopyMiscFiles
 * Copy other files to directory tree
 * @return boolean true on success
 */
global define boolean CopyMiscFiles() ``{

    string cpCmd = "";
    string arch = Arch::architecture();
    y2debug("isolinux.cfg: %1", Config["bootconfig"]:"" );
    if (Config["bootconfig"]:"" != "") 
    {
        y2debug("custom config available");

	string fname = (Config["code10"]:false)
	    ? sformat("%1/boot/%2/loader/isolinux.cfg", skel_root, arch)
	    : sformat("%1/boot/loader/isolinux.cfg", skel_root);

        SCR::Write(.target.string, fname, Config["bootconfig"]:"" );
        /*
        string cpCmd = sformat("cp %1/cd-creator/isolinux.cfg %2/boot/loader",
            Directory::datadir, skel_root);
        SCR::Execute (.target.bash, cpCmd);
            */
    }
    cpCmd = (Config["code10"]:false)
	? sformat("cp %1/cd-creator/message %2/boot/%3/loader", Directory::datadir, skel_root, arch)
	: sformat("cp %1/cd-creator/message %2/boot/loader", Directory::datadir, skel_root);
    SCR::Execute (.target.bash, cpCmd);

    cpCmd = (Config["code10"]:false)
	? sformat("cp %1/cd-creator/options.msg %2/boot/%3/loader", Directory::datadir, skel_root, arch)
	: sformat("cp %1/cd-creator/options.msg %2/boot/loader", Directory::datadir, skel_root);
    SCR::Execute (.target.bash, cpCmd);


    return true;
}



/**
 * Enable source and get source meta data
 * @return true on success
 */
global define boolean EnableSource() ``{
    y2milestone("Config: %1", Config);
    enableSources();

    list<integer> sources = UrlToId(CDCreator::Config["sources"]:[]);

    list ids = Pkg::SourceStartCache(true);

    if (size(ids) == 0 )
	return false;

    foreach(integer i , sources, ``{
	map<string, any> m = $[];
	m["productData"] = Pkg::SourceProductData(i);
	m["mediaData"] = Pkg::SourceMediaData(i);
	m["sourceData"]	= Pkg::SourceGeneralData(i);
        string p = m["sourceData", "url"]:"";
        map parsed = URL::Parse(p);
        m["path"] = parsed["path"]:"";
	meta[i] = m;
    });

    y2milestone("meta: %1", meta);
    return true;
}


/**
 * Get all possible sources
 * @return available enabled sources list for widget
 */
global define list<term> GetDirSources(string source) ``{
    list<integer> ids = Pkg::SourceStartCache(true);
    list<term> sources = [];
    foreach(integer i , ids, ``{
        map prod = Pkg::SourceProductData(i);
        map media = Pkg::SourceMediaData(i);
	map url = URL::Parse(media["url"]:"");
	if (url["scheme"]:"" == "dir")
	{
	    boolean selected = (source == url["path"]:"");
	    sources = add(sources, `item(`id(url["path"]:""), url["path"]:"", selected));

	}
    });

    return sources;
}


/**
 * Check Product dependencies and determine product to be used for
 * booting. Also determine what is the main product.
 *
 */
global define list checkProductDependency() ``{

    list<integer> sources = UrlToId(Config["sources"]:[]);

    list<map> products = maplist(integer id , sources, ``{
	map generalData = Pkg::SourceGeneralData( id );
	map productData = Pkg::SourceProductData( id );

	map result = $[];

	result["baseproduct"] = sformat("%1-%2", productData["baseproductname"]:"", productData["baseproductversion"]:"" );
	result["vendor"] = productData["vendor"]:"";
	result["product"] = sformat("%1-%2", productData["productname"]:"", productData["productversion"]:"" );
	result["is_service_pack"] = ( issubstring(productData["productname"]:"", "Service-Pack") );
	result["id"] = id;
	return(result);
    });

    list<map> final = maplist( map product, products, ``{
	list<map> based_on_this = filter(map p, products, ``(product["product"]:"" == p["baseproduct"]:""));
	list<integer> ids = maplist(map p, based_on_this, ``(p["id"]:-1));
	y2milestone("Products based on %1: %2", product["product"]:"", based_on_this );
	product["dependents"] = ids;
	return(product);
    });


    map installedProduct = (map)filter(map p, final, ``(size(p["dependents"]:[]) == 0
								      && !p["is_service_pack"]:false
								      && issubstring(p["vendor"]:"", "SuSE")))[0]:$[];
    Config["product"] = installedProduct["product"]:"";
    y2milestone("all: %1", final);
    return final;

}


global define void enableSources()``{

    Pkg::SourceStartManager(false);

    y2milestone("sources: %1", CDCreator::Config["sources"]:[]);
    list<integer> sources = UrlToId(CDCreator::Config["sources"]:[]);
    y2milestone("source IDs: %1", sources);

    foreach(integer id , Pkg::SourceGetCurrent(true), ``{
		y2milestone("Disabling source %1", id);
                Pkg::SourceSetEnabled (id, false);
	});


    foreach(integer id , sources, ``{
		y2milestone("Enabling source %1", id);
		Pkg::SourceSetEnabled(id, true);
	});

    Pkg::SourceStartManager(true);

    y2milestone("All sources: %1", Pkg::SourceGetCurrent(false));
    y2milestone("Enabled sources: %1", Pkg::SourceGetCurrent(true));

    return;
}



/**
 * Set packages to be copied to iso image tree
 * @return boolean
 */
global define boolean setPackages() ``{
    string base = Config["base"]:"";
    list<string> addons = Config["addons"]:[];
    list<string> packages  = Config["packages"]:[];
    list<string> post_packages  = Config["post-packages"]:[];
    string kernel = Config["kernel"]:"";
    list<string> kernels = [];

    if (kernel == "") {
        kernels = [
                   "kernel-64k-pagesize",
                   "kernel-bigsmp",
                   "kernel-debug",
                   "kernel-default",
                   "kernel-iseries64",
                   "kernel-pmac64",
                   "kernel-pseries64",
                   "kernel-s390",
                   "kernel-s390x",
                   "kernel-smp",
                   "kernel-sn2",
		   "kernel-xen",
                   "kernel-um"
		   ];
    } else {
        kernels = add(kernels, kernel);
    }


    if (Config["type"]:`unknown == `patterns)
    {
	// base pattern
	if (base != "")
	{
	    Pkg::ResolvableInstall(base, `pattern);
	}

	if (size(addons) > 0 )
	{
	    foreach(string p, addons, ``{
		Pkg::ResolvableInstall(p, `pattern);
	    });
	}
    }
    else
    {
	// Base Selection
	if (base!="")
	{
	    Pkg::SetSelection(base);
	}

	// Addons
	if (size(addons) > 0 )
	{
	    foreach(string s, addons, ``{
		Pkg::SetSelection(s);
	    });
	}
    }

    packages = (list<string>) union(packages, post_packages);
    packages = (list<string>)union(packages, kernels);

    y2milestone("Selected packages: %1", packages);

    Pkg::DoProvide(packages);

    boolean ret = Pkg::PkgSolve(false);

    return (ret);
}


/**
  * getRpmPath
  * get physical rpm location
  * @return: package path
  */
global define  string  getRpmPath( map package_data)
{

    y2debug("package data: %1", package_data );
    integer srcid = package_data["srcid"]:-1;
    map s = meta[srcid]:$[];
    map pd = s["productData"]:$[];
    map md = s["mediaData"]:$[];
    string dataDir = pd["datadir"]:"./suse";
    string url = md["url"]:"";
    map urlmap = URL::Parse(url);
    string ArchLocation =  sformat("%1/%2", package_data["arch"]:"noarch", package_data["location"]:"norpm.rpm");
    string p = urlmap["path"]:"";
    list<string> pp = splitstring(p, "/");
    if (pp[size(pp)-1]:"" == "CD1" ) {
        pp[size(pp)-1] = sformat("CD%1", package_data["medianr"]:1);
    }
    else if  (pp[size(pp)-2]:"" == "CD1" ) {
        pp[size(pp)-2] = sformat("CD%1", package_data["medianr"]:1);
    }

    p = mergestring(pp, "/");
    y2debug("new path: %1", p);
    string FullPath =  p + "/" + dataDir + "/" + ArchLocation;
    return FullPath;
};


global define boolean verifyDestination() ``{
    string isodir = Config["iso-directory"]:"" + "/"  + Config["name"]:"";
    if ((integer)SCR::Read(.target.size, Config["iso-directory"]:"" + "/"  + Config["name"]:"") > 0 ) { // its a file!
        if (Popup::YesNo(sformat(_("Destination directory exists or is a file.
Remove directory %1?") , isodir)))
	{
	    y2milestone("Removing directory %1", isodir);
            SCR::Execute(.target.bash, "rm -rf " + isodir );
	}
        else
            return false;
    }
    return true;
}

/**
 * Check if selected packages are available
 * @return string error message
 */
global define string checkPackageAvail() ``{

    string error_msg = "";

    Progress::Title(_("Checking for package availability..."));

    list<string> selectedPackages = Pkg::GetPackages (`selected , true);

    list<string> failed = [];
    toCopy = [];
    foreach(string package, selectedPackages, ``{

	map package_data = Pkg::PkgProperties(package);
	string FullPath = getRpmPath(package_data);
	y2debug("Checking for package: %1 ",  FullPath);
	integer package_size = (integer)SCR::Read(.target.size, FullPath);
	if (package_size == -1 )
	{
	    failed = add (failed, FullPath);
	}
	else
	{
	    string arch =  package_data["arch"]:"noarch";
	    toCopy = add(toCopy, $["path": FullPath, "name": package, "arch":  arch ]);
	}
    });
    CDCreator::missing_packages = failed;
    if (size(failed) > 0 )
    {
	integer num = size(failed);
	error_msg = sformat(_("%1 package not available.", "%1 packages not available.", num), num);
    }
    y2milestone("packages not found: %1", failed);

    return error_msg;
}





/**
 * CopyPackages()
 * Copy selected package to target tree
 * @param integer id
 * @return boolean
 */
global boolean CopyPackages()
{
    string datadir  = "suse";
    string basedir = Config["iso-directory"]:"" + "/" +  Config["name"]:"" +
        "/" +  datadir;
    foreach(map package, toCopy, ``{

	Progress::Title(sformat(_("Copying %1"), package["name"]:"..." ));
	Progress::NextStep();
	string dir = basedir + "/" + package["arch"]:"";

	if (SCR::Read(.target.dir, dir) == nil )
	{
            y2milestone("Creating dir: %1", dir);
	    SCR::Execute(.target.mkdir , dir);
            y2debug("dir contents: %1", (list)SCR::Read(.target.dir, dir));
	}

	string cpCmd = sformat("cp %1 %2", package["path"]:"", dir );

	y2debug("%1", cpCmd);

	any ret = SCR::Execute (.target.bash, cpCmd);
        if (ret!=0)
        {
            Popup::Error(_("Error while copying packages. 
Check the created directory for possible hints."));
            return false;
        }

    });
    SCR::Execute(.target.bash, sformat("cd %1 && " +
                "/usr/bin/create_package_descr -x setup/descr/EXTRA_PROV",
                basedir));

    return true;
}



global define boolean readControlFile(string filename) ``{

    if (profile_parsed)
        return true;
    if (!Profile::ReadXML(filename))
    {
        Report::Error(_("Error reading control file."));
        return false;
    }
    y2debug("Current profile: %1", Profile::current);

    map software = Profile::current["install", "software"]:$[];

    if (size(software) == 0)
    {
	software = Profile::current["software"]:$[];
    }

    y2milestone("Software config: %1", software);

    if (haskey(software, "patterns"))
    {
	y2milestone("Switching to profile based config");
	Config["type"] = `patterns;
	list<string> pats = software["patterns"]:[];
	Config["base"] = pats[0]:"";

	if (size(pats) > 1)
	{
	    Config["addons"] = remove(pats, 0);
	}
    }
    else
    {
	y2milestone("Using selections based config");
	Config["base"] = software["base"]:"";
	Config["addons"] = software["addons"]:[];
    }

    PackageAI::toinstall = software["packages"]:[];
    Config["packages"] = AutoinstSoftware::autoinstPackages();
    y2milestone("Config: %1", Config );
    profile_parsed = true;
    return true;
}

/**
 * Constructor
 */
global define void CDCreator() ``{
    configSetup();
    AYRepository = Misc::SysconfigRead( .sysconfig.autoinstall.REPOSITORY, 
            "/var/lib/autoinstall/repository/");

//    // Store original status
//    old_enabled = Pkg::SourceGetCurrent(true);
//    y2debug("old_enabled=%1", old_enabled );
}


/* EOF */
}
